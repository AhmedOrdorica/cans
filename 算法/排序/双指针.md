## 1.介绍
> 双指针（Two Pointers）：指的是在遍历元素的过程中，不是使用单个指针进行访问，而是使用两个指针进行访问，从而达到相应的目的。

> 对撞指针：指的是两个指针 left、right 分别指向序列第一个元素和最后一个元素，然后 left 指针不断递增，right 不断递减，直到两个指针的值相撞（即 left == right），或者满足其他要求的特殊条件为止。

## 2.性质

### 时间复杂度
双指针的时间复杂度一般都是 O(n)，因为双指针的遍历过程中，只需要遍历一遍序列，所以时间复杂度是 O(n)。

### 空间复杂度
双指针的空间复杂度一般都是 O(1)，因为双指针的遍历过程中，只需要使用常数个变量，所以空间复杂度是 O(1)。

## 3.应用

### <font style="color:orange"> 题目1 </font>

[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

**说明**：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

**示例**:

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**解题思路**：对撞指针
1. 定义两个指针 `left`、`right` 分别指向数组的第一个元素和最后一个元素
2. 定义一个数组 `res`，用于存储平方后的结果，数组的长度为 `nums` 的长度，数组用 `0` 填充
3. 定义一个变量 `cur`，记录当前填充的位置
4. 比较 `nums[left]` 和 `nums[right]` 的平方，将较大的值填充到 `res[cur]` 中，然后 cur 自减 `1`, 并且将较大的值对应的指针向中间移动一位
5. 重复步骤 4，直到 `left == right`，此时 `res[cur]` 就是最后一个元素的平方
6. 返回 `res`

```php
<?php
class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function sortedSquares($nums) {
        $left = 0;
        $cur = count($nums) - 1;
        $right = count($nums) - 1;
        $res = array_fill(0,$cur,0); // 用0填充数组

        do {
            $leftDup = $nums[$left] * $nums[$left];
            $rightDup = $nums[$right] * $nums[$right];

            if($leftDup > $rightDup) {
                $res[$cur] = $leftDup;
                $left++;
            } else {
                $res[$cur] = $rightDup;
                $right--;
            }
            $cur--;

        } while($left<=$right);

        return $res;
    }
}
```

PS: 当然，这道题还有更暴力的思路：先全部平方，然后排序。